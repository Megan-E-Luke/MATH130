---
title: "Week 3 notes for section 01"
output: html_document
---

# Factor management
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
email <- read.table("J:/MATH130/fall18/email.txt", header=TRUE, sep="\t")
```

## creating factors
Starting with a numerical variable

```{r}
table(email$spam)
class(email$spam)
```
R sees this variable as numeric, not as codes that stand for "Not spam" and "spam".
To **create** a factor variable we use the `factor()` command - use the labels argument

```{r}
email$spam_fac <- factor(email$spam, labels=c("Not spam", "Spam"))
```

The order of the lables is SPECIFIC. 

Always confirm your recode. the way I do it is to create a crosstab (2way table) of original variable X new variable - and show NA

```{r}
table(email$spam, email$spam_fac, useNA = "always")
```


## Reordering factors

We're going to "re-factor" existing factors. There is a lot of different ways to manage your factors. THIS is where you specify **levels** 

```{r}
email$number <- factor(email$number, levels=c("none", "small", "big"))
table(email$number) # confirm reorder worked
```


# dplyr

```{r}
library(nycflights13)
library(dplyr)
flights
```

The first argument in any dplyr function is the data set. 

## filter
All arguments after the data are the filter criteria.
Comma's work as "and"

Just look at flights from jan 1st.
```{r}
filter(flights, month==1, day==1)
```

flights in jan OR feb

```{r}
janorfeb <- filter(flights, month==1 | month==2) 
janorfeb <- filter(flights, month %in% c(1,2)) # also a way to use an "or" 
table(janorfeb$month)
```


## select

```{r}
select(flights, month, day, year) # order is specified
select(flights, year:day)
```


select can be used to exclude variables by using a - sign.
```{r}
select(flights, -year, -month, - day)
```

## mutate makes new variables

more powerful than using $ sign notation because you can 

1. make multiple new variables in the same statement (use a comma to separate)
2. refer to variables you just created

Add the new variables `gain` and `speed` to the `flights` data set. 
```{r}
a <- mutate(flights, gain = arr_delay - dep_delay, 
                     speed = distance / air_time * 60, 
                     gain_per_hour = gain / (air_time / 60))

select(a, arr_delay, dep_delay, gain, distance, air_time, speed)
```

Things to note

* tabs don't matter. They are for readabilty.


## summarize
only useful with group by
the two command below are identical
```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
mean(flights$dep_delay, na.rm=TRUE)
```




# Dplyr continued

* filter is used to choose rows that meet a criteria (aka subsetting)
* select is used to choose columns 
* mutate is used to make NEW variables 
    - key advantage is that it bypasses $ notation
    - can call variables that were just created

Other thing to note here is the code "alignment" -- for readability only
```{r}
a <- mutate(flights, gain = arr_delay - dep_delay, 
                     speed = distance / air_time * 60, 
                     gain_per_hour = gain / (air_time / 60 ))
select(a, arr_delay, dep_delay, gain, distance, air_time, speed)
```

Does the same as
```{r, eval=FALSE}
flights$gain <- flights$arr_delay - flights$dep_delay
```

## summarize
Only really useful (IMO) when combined with `group_by`. 

To calculate the average departure delay
```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
mean(flights$dep_delay, na.rm = TRUE)
```

# Group_by
All it does is apply a "flag" to the data that says this data is grouped, and to do ALL subsequnt operations on each group.

```{r}
str(flights)
by_month <- group_by(flights, month)
str(by_month)
```


So now if I want to sort the data by distance flown (and then display only the month and distance variables)
```{r}
arrange(flights, distance) %>% select(month, distance) 
```


grouped summary statistics
```{r}
mean(flights$distance, na.rm=TRUE)
summarise(by_month, avg_airtime = mean(distance, na.rm=TRUE))
```


count the # of flights

```{r}
summarize(flights, count=n())
summarize(by_month, count=n())
```


Typical data processing path without chaining. 

goal: produce a data set that contains only the flights where the daily average delay is greater than a half hour.

```{r}
a1 <- group_by(flights, year, month, day)
a2 <- select(a1, arr_delay, dep_delay)
head(a2)
```

calculate average delay per day
```{r}
a3 <- summarise(a2,
                arr = mean(arr_delay, na.rm = TRUE),
                dep = mean(dep_delay, na.rm = TRUE))
head(a3)
```

```{r}
a4 <- filter(a3, arr > 30 | dep > 30)
head(a4)
```

```{r}
prop.table(table(flights$month))
```


All of the steps above can be "chained" together using %>%
```{r}
flights %>%
  group_by(year, month, day) %>%
  select(arr_delay, dep_delay) %>%
  summarise(
    arr = mean(arr_delay, na.rm = TRUE),
    dep = mean(dep_delay, na.rm = TRUE)
  ) %>%
  filter(arr > 30 | dep > 30)
```

Notice now that in each of the dplyr verbs (like select) -- the data set name no longer is included. 

The pipe (%>%) takes the data set on the left, and puts it into the first argument on the right. 
```{r}
flights %>% group_by(year, month, day)
# the same as
group_by(flights, year, month, day)
```



